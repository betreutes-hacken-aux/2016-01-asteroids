\documentclass[dvips,12pt,xcolor=table]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
%\usepackage{minted}

\begin{document}

\begin{frame}
\frametitle{Bewegung}
\framesubtitle{Homogene Koordinaten}
\textbf{Karthesische Koordinaten (2D) zu homogenen Koordinaten:}
\begin{description}
 \item[Ortsvektoren:]
  \begin{equation}
   \left(\begin{array}{c}
    x \\
    y \\
   \end{array}\right)
   \rightarrow
   \left(\begin{array}{c}
    x \\
    y \\
    1 \\
   \end{array}\right)
  \end{equation}

 \item[Richtungsvektoren:]
  \begin{equation}
   \left(\begin{array}{c}
    x \\
    y \\
   \end{array}\right)
   \rightarrow
   \left(\begin{array}{c}
    x \\
    y \\
    0 \\
   \end{array}\right)
  \end{equation}
\end{description}
\end{frame}

\begin{frame}
\frametitle{Bewegung}
\framesubtitle{Homogene Koordinaten}
\textbf{Homogenen Koordinaten (2D) zu karthesischen Koordinaten: \\}
\begin{equation}
 \left(\begin{array}{c}
  x \\
  y \\
  w \\
 \end{array}\right)
 \rightarrow
 \left(\begin{array}{c}
  \frac{x}{w} \\
  \\
  \frac{z}{w} \\
 \end{array}\right)
\end{equation}
\end{frame}

\begin{frame}
\frametitle{Bewegung}
\framesubtitle{Homogene Koordinaten}
\textbf{Rotationen: \\}
Rotation um $\varphi$ entgegen dem Uhrzeigersinn:
\begin{equation}
 \left(\begin{array}{ccc}
  cos(\varphi) & -sin(\varphi) & 0 \\
  sin(\varphi) & cos(\varphi) & 0 \\
  0 & 0 & 1 \\
 \end{array}\right)
\end{equation}
\hspace{2mm}
Beispiel: Den Punkt $(2, 1)^{T}$ um $90^{\circ}$ rotieren.
\begin{equation}
 \left(\begin{array}{ccc}
  cos(90^{\circ}) & -sin(90^{\circ}) & 0 \\
  sin(90^{\circ}) & cos(90^{\circ}) & 0 \\
  0 & 0 & 1 \\
 \end{array}\right)
 \cdot
 \left(\begin{array}{ccc}
  2 \\
  1 \\
  1 \\
 \end{array}\right)
 =
 \left(\begin{array}{ccc}
  -1 \\
  2 \\
  1 \\
 \end{array}\right)
\end{equation}
\end{frame}

\begin{frame}
\frametitle{Bewegung}
\framesubtitle{Homogene Koordinaten}
\textbf{Translationen: \\}
\begin{equation}
 \left(\begin{array}{ccc}
  1 & 0 & t_{x} \\
  0 & 1 & t_{y} \\
  0 & 0 & 1 \\
 \end{array}\right)
\end{equation}
Anwendung auf einen Richtungsvektor:
\begin{equation}
 \left(\begin{array}{ccc}
  1 & 0 & t_{x} \\
  0 & 1 & t_{y} \\
  0 & 0 & 1 \\
 \end{array}\right)
 \cdot
 \left(\begin{array}{ccc}
  x \\
  y \\
  w \\
 \end{array}\right)
 =
 \left(\begin{array}{ccc}
  x + t_{x} \cdot w \\
  y + t_{y} \cdot w \\
  w \\
 \end{array}\right)
\end{equation}
Beobachtung:
Eine Translation wirkt sich nur auf Ortsvektoren,
nicht auf Richtungsvektoren aus,
da für diese $w = 0$.
\end{frame}


\begin{frame}
\frametitle{Bewegung}
\framesubtitle{OpenGL 2.x}
Zwei Matrizen:
\begin{description}
 \item[Modelview Matrix] \hfill \\
  Auslesbar mit
  \texttt{glGetFloatv(GL\_MODELVIEW\_MATRIX)}.
  Diese Matrix wird zuallerst
  auf alle übergebenen 3D-Koordinaten angewendet.
 \item[Projection Matrix] \hfill \\
  Auslesbar mit
  \texttt{glGetFloatv(GL\_PROJECTION\_MATRIX)}.
  Ihre Aufgabe besteht darin 3D-Koordinaten
  auf eine 2D-Fläche zu projizieren.
\end{description}
\end{frame}

\begin{frame}
\frametitle{Bewegung}
\framesubtitle{OpenGL 2.x}
Zwei Matrizen:
\begin{description}
 \item[Modelview Matrix]
 \item[Projection Matrix]
\end{description}
\texttt{glMatrixMode(mode)} legt fest,
welche Matrix aktuell bearbeitet werden soll.
Diese kann mit Befehlen wie
\texttt{glPopMatrix},
\texttt{glLoadIdentity},
\texttt{glPushMatrix},
\texttt{glMultMatrix},
\texttt{glRotated} und
\texttt{glTranslated}
bearbeitet werden.
\end{frame}

\end{document}
